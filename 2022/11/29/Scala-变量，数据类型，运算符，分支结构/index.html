<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content>
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          Scala_变量，数据类型，运算符，分支结构 - Jiaxuan的博客 | Jiaxuan&#39;s Blog
        
    </title>

    <link rel="canonical" href="https://radiationxuan.github.io/2022/11/29/Scala-变量，数据类型，运算符，分支结构/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Jiaxuan&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">My resume</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="https://radiationxuan.github.io/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                    </div>
                    <h1>Scala_变量，数据类型，运算符，分支结构</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by Jiaxuan on
                        2022-11-29
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="Scala入门-变量，数据类型，运算符，分支结构"><a href="#Scala入门-变量，数据类型，运算符，分支结构" class="headerlink" title="Scala入门(变量，数据类型，运算符，分支结构)"></a>Scala入门(变量，数据类型，运算符，分支结构)</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Scala 声明变量的关键字有两个：<code>var</code> &amp; <code>val</code>。</p>
<p><code>var</code> 用于可变变量的声明，是 <code>variable</code> 的简写；</p>
<p><code>val</code> 用于常量的声明，是 <code>value</code>的简写</p>
<p><code>var</code> 与 <code>val</code> 的区别：<code>val</code> 用于声明的常量，当赋值之后就不能再改，尝试修改值时会编译错误。不可变的值意味着它是线程安全的，不需要锁机制来保持同步。因为这个优点，在后续的函数式 / 并发编程中，<strong>优先使用值拷贝来传递状态，避免修改变量来改变状态</strong>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="type">Object</span>()</span><br><span class="line">obj1 = <span class="keyword">new</span> <span class="type">Object</span>()   <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> obj2 = <span class="keyword">new</span> <span class="type">Object</span>()</span><br><span class="line">obj2 = <span class="keyword">new</span> <span class="type">Object</span>()  <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>另外，<code>val</code> 变量赋值为一个引用对象时，可以改变对象的属性，但不能再指向其他对象，所以 <code>val</code>可以理解为 Java 中用 <code>final</code> 修饰的变量。</p>
<p>Scala 中允许不使用分号表示语句结束，换行即认为新语句的开始</p>
<p>与 Java 声明变量时必须要指定变量类型不同，<code>Scala 具有类型推断的特性</code>，就不需要显示地声明类型，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: <span class="type">Int</span> = <span class="number">1</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> y: <span class="type">String</span> = <span class="string">"abc"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">1</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="string">"abc"</span></span><br></pre></td></tr></table></figure>
<p>对于<code>val</code>类型的值，Scala 支持将其延迟加载。举一个例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t1 = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"><span class="keyword">val</span> expensive = &#123;<span class="type">Thread</span>.sleep(<span class="number">1000</span>);<span class="string">"hello"</span>&#125;</span><br><span class="line"><span class="keyword">val</span> duration = <span class="type">System</span>.currentTimeMillis() - t1</span><br><span class="line">println(<span class="string">s"duration: <span class="subst">$&#123;duration&#125;</span>ms"</span>)</span><br></pre></td></tr></table></figure>
<p>由于 <code>expensive</code> 的赋值块内部包含了一条休眠命令，因此程序对其进行初始化时需要停顿将近 1 秒的时间，即便 <code>expensive</code> 在后面的程序中并没有用到。这种情况下，对 <code>expensive</code> 进行初始化是一种资源的浪费。在实际场合，如果不确定一个变量是否会被使用，且初始化代价又十分高昂时，那么不妨使用 <code>lazy</code> 关键字令它被延迟加载。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它现在只会在第一次被调用时加载。</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> expensive = &#123;<span class="type">Thread</span>.sleep(<span class="number">1000</span>);<span class="string">"hello"</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://cdn.staticaly.com/gh/Radiationxuan/img@main/20221202/scala数据类型.4y6y2fcmhz80.webp" alt="scala数据类型"></p>
<p>Java 中有八大基础数据，Scala 则有九个基础数据类型， 除了一样有 <code>Double</code>，<code>Float</code>，<code>Long</code>，<code>Int</code>，<code>Short</code>，<code>Byte</code>，<code>Boolean</code>，还额外多一个 <code>Unit</code> 类型，它表示不带任何意义的类型，有且仅有一种值：<code>()</code> ，可以理解为 Java 中的 <code>void</code>，在函数定义时使用表示该函数无返回值。</p>
<p><code>Any</code>是所有是所有数据类型的顶类型，<code>Nothing</code> 则是所有类型的底类型。<code>Null</code> 类型有且只有一个值：<code>null</code>。它是所有 <code>AnyRef</code> 类的底类型，这样设计的目的是可以将 <code>null</code> 赋值给任何一个 <code>AnyRef</code> 类型。</p>
<p><code>Unit</code> 被归为 <code>AnyVal</code> 的子类型。它用于表示函数没有返回值，比如主程序的返回值就是 <code>Unit</code> 类型。它有且只有一个值，为 <code>()</code>。</p>
<p>在 <code>AnyVal</code> 和 <code>AnyRef</code> 之上的就是 Scala 最顶级的类型 ，它定义了一些最通用的方法如 <code>equals</code>，<code>hashCode</code> 和 <code>toString</code>。</p>
<p>下表给出了不同数据类型的值域：</p>
<table>
<thead>
<tr>
<th>type</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Byte</code></td>
<td>8 位 ( 1 字节 ) 有符号补码整数。区间 -128 ~ 127。</td>
</tr>
<tr>
<td><code>Short</code></td>
<td>16 位 ( 2 字节 ) 有符号补码整数。区间 -(2^16) ~ (2^16)-1</td>
</tr>
<tr>
<td><code>Int</code></td>
<td>32 位 ( 4 字节 ) 有符号补码整数。区间 -(2^32) ~ (2^32)-1</td>
</tr>
<tr>
<td><code>Long</code></td>
<td>64 位 ( 8 字节 ) 有符号补码整数。区间 -(2^64) ~ (2^64)-1</td>
</tr>
<tr>
<td><code>Float</code></td>
<td>32 位，IEEE 754 标准的单精度浮点数。</td>
</tr>
<tr>
<td><code>Double</code></td>
<td>64 位，IEEE 754 标准的单精度浮点数。</td>
</tr>
<tr>
<td><code>Char</code></td>
<td>16 位无符号的 Unicode 字符，区间值为 U+0000 ~ U+FFFF。</td>
</tr>
<tr>
<td><code>String</code></td>
<td>字符序列。</td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td>只有两个值：<code>true</code> 和 <code>false</code>。</td>
</tr>
<tr>
<td><code>Unit</code></td>
<td>只有唯一值 <code>()</code>，常用于表示方法 / 函数无返回值，相当于 Java 的 <code>void</code>。</td>
</tr>
<tr>
<td><code>Null</code></td>
<td>只有唯一值 <code>null</code>，表示空的对象。</td>
</tr>
<tr>
<td><code>Nothing</code></td>
<td>是所有 Scala 类型的底类型，常用于抛出异常。</td>
</tr>
<tr>
<td><code>Any</code></td>
<td>是所有 Scala 类型的顶类型。</td>
</tr>
<tr>
<td><code>AnyRef</code></td>
<td>是 Scala 一切引用类型的父类型。</td>
</tr>
</tbody>
</table>
<h3 id="Nothing和Null"><a href="#Nothing和Null" class="headerlink" title="Nothing和Null"></a>Nothing和Null</h3><p>Scala 类型层次图底部还有两个类型 <code>Nothing</code> 和 <code>Null</code>，<code>Nothing</code>是所有类型的子类型，该类型下没有任何一个值，主要用于程序的异常和中断的非正常返回；而 <code>Null</code> 为引用类型的子类型，只有一个值：<code>null</code> ，主要是在与 Java 交互时使用。</p>
<h3 id="值类型转换"><a href="#值类型转换" class="headerlink" title="值类型转换"></a>值类型转换</h3><p><img src="https://cdn.staticaly.com/gh/Radiationxuan/img@main/20221202/类型转换.5oemifj7w5k0.webp" alt="类型转换"></p>
<blockquote>
<p>低精度的值可以赋值给高精度类型的变量或值，该过程是自动转换。反之则需要牺牲精度，该过程是强制转换。</p>
</blockquote>
<p>在多种类型的数据混合计算时，系统的计算结果取 <strong>精度最大的数据类型</strong>。比如，<code>Int</code> 和 <code>Float</code> 的数值运算是 <code>Float</code> 类型，<code>Int</code> 和 <code>Long</code> 的数值计算是 <code>Long</code> 类型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a : <span class="type">Int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">val</span> b : <span class="type">Long</span> = <span class="number">200</span>l</span><br><span class="line"><span class="keyword">val</span> c = a + b  <span class="comment">// c : Long</span></span><br></pre></td></tr></table></figure>
<p>低精度类型的变量接受高精度值时需要以牺牲精度的代价进行 <strong>强制转换</strong>。比如：<code>Float</code> 是比 <code>Int</code> 精度更高的类型，因此将 <code>Float</code> 值赋给 <code>Int</code> 变量时必须进行强制转换。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a : <span class="type">Int</span> = <span class="number">1.4</span>f.toInt</span><br></pre></td></tr></table></figure>
<p>一切 <code>AnyVal</code> 类型都可以调用 <code>toString</code> 方法转换为 <code>String</code> 类型；<code>String</code> 类型也可以通过 <code>toXXX</code> 方法转换成值类型。如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a : <span class="type">Int</span> = <span class="string">"100"</span>.toInt         <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">val</span> b : <span class="type">String</span> = <span class="number">100.</span>toString     <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">val</span> c : <span class="type">Double</span> = <span class="string">"hello"</span>.toDouble <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><blockquote>
<p>形式上，我们习惯将定义在 object 单例对象的称之<em>函数</em> ( function )，将定义在 class 类上的称之为 <em>方法</em> ( method )。</p>
</blockquote>
<p>在命名变量，函数或方法时所使用的字符序列可统称 <em>标识符</em>。可以使用 <strong>反引号</strong> 区分那些和关键字重名的标识符 ( 但并不推荐 )。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> `<span class="keyword">val</span>` = <span class="number">100</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>Scala 允许使用<strong>连续的两个及以上的字符</strong> 表示一个标识符，比如 <code>++</code>，<code>--</code>，<code>?!</code>，<code>^^</code>，<code>&lt;-&gt;</code> 等。注意，<code>$</code> 和 <code>_</code> 以及左右括号，方括号，花括号不能作为标识符。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ~@! : <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> &lt;-&gt; : <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">&lt;==</span> </span>: <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">=&gt;|</span> </span>: <span class="type">Int</span> = <span class="number">3</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>特殊的，这四个单字符 <code>+</code>，<code>-</code> ，<code>*</code>，<code>/</code> 可以用来表示一个标识符。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> + : <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> - : <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> / : <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> * : <span class="type">Int</span> = <span class="number">3</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>Scala 丰富的标识符表示法为构建领域内部语言 DSL 提供了基础。为了避免混乱，这些符号标识符一般仅用于某个上下文语境内定义函数或方法，后文统称这样的标识符为 <em>运算符</em>。对 <code>+</code>，<code>-</code>，<code>*</code>，<code>/</code> 等常见运算符的重定义也称 <em>运算符重载</em> 。</p>
<p>按照功能来看，运算符可以分为三类：<strong>算数运算符</strong>， <strong>赋值运算符</strong> 和 <strong>关系运算符</strong>。按照和操作数的关系，运算符又可分为：</p>
<ol>
<li>前缀运算符</li>
<li>中缀运算符</li>
<li>后缀运算符</li>
</ol>
<p>其它语言的大部分基础运算符在 Scala 也是通用的，比如移位 <code>&gt;&gt;</code> ，取模 <code>%</code>，等等，不过需要补充的是，Scala 没有三目运算符 ( 被选择分支替代 )，也没有自增 <code>++</code> 自减 <code>--</code> 运算，因为这两种自操作潜在地破坏了变量原有的状态，这种做法是不被 Scala 推崇的。若要对 <code>var</code> 变量实现自增 / 自减操作，则必须使用 <code>+=</code> 和 <code>-=</code> 表示运算并重赋值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">3</span></span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>本章的重点是使用 Scala 自定义运算符。</p>
<h3 id="中缀运算符"><a href="#中缀运算符" class="headerlink" title="中缀运算符"></a>中缀运算符</h3><p>如果类方法的参数只有一个，那么该方法就可以作为中缀运算符。如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">andThen</span></span>(other: <span class="type">State</span>) = <span class="keyword">this</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inFinal</span></span>(other: <span class="type">State</span>) = ()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> s1 = <span class="keyword">new</span> <span class="type">State</span>()</span><br><span class="line"><span class="keyword">val</span> s2 = <span class="keyword">new</span> <span class="type">State</span>()</span><br><span class="line"><span class="keyword">val</span> s3 = <span class="keyword">new</span> <span class="type">State</span>()</span><br><span class="line"></span><br><span class="line">s1.andThen(s2).inFinal(s3)</span><br><span class="line"><span class="comment">// 中缀表达式写法</span></span><br><span class="line">s1 andThen s2</span><br><span class="line"><span class="comment">// 保留从左到右的运算顺序</span></span><br><span class="line">s1 andThen s2 inFinal s3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>看，我们无意间就生成了一个易于理解的，连贯的最简单 DSL。注意，无论是哪种表现形式，Scala 总是按照从左到右的顺序严格计算。如果追求完全符号化的表达，也可以这样设计：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">andThen</span></span>(other: <span class="type">State</span>) = <span class="keyword">this</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inFinal</span></span>(other: <span class="type">State</span>) = ()</span><br><span class="line">  <span class="comment">/** warped andThen*/</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">|=&gt;</span> </span>(other : <span class="type">State</span>) = andThen(<span class="keyword">this</span>)</span><br><span class="line">  <span class="comment">/** warped inFinal */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">=|</span> </span>(other : <span class="type">State</span>) = inFinal(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> s1 = <span class="keyword">new</span> <span class="type">State</span>()</span><br><span class="line"><span class="keyword">val</span> s2 = <span class="keyword">new</span> <span class="type">State</span>()</span><br><span class="line"><span class="keyword">val</span> s3 = <span class="keyword">new</span> <span class="type">State</span>()</span><br><span class="line"></span><br><span class="line">s1 |=&gt; s2 =| s3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="后缀运算符"><a href="#后缀运算符" class="headerlink" title="后缀运算符"></a>后缀运算符</h3><p>如果类方法是空参数的，那么该方法就可以视作一个后缀运算符。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scala 建议通过引入它来开启后缀运算符特性。</span></span><br><span class="line"><span class="keyword">import</span> scala.language.postfixOps</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span>(<span class="params">var zeroV : <span class="type">Int</span></span>)</span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">next</span> </span>: <span class="type">Int</span> = zeroV + <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">val</span> generator =<span class="keyword">new</span> <span class="type">Generator</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">val</span> v1 = generator next   <span class="comment">// return 1</span></span><br><span class="line"><span class="keyword">val</span> v2 = generator next   <span class="comment">// return 2</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>注意，这里的 <code>next</code> 方法其实是一个无参数方法，因为它没有小括号 <code>()</code> 表示的参数列表。空参数函数和无参数函数两者存在略微区别，我们之后再说。同理，可以为它设计一些符号化的表达：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span>(<span class="params">var zeroV : <span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span> </span>: <span class="type">Int</span> = zeroV + <span class="number">1</span></span><br><span class="line">  <span class="comment">/** warped next */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">&gt;&gt;</span> </span>: <span class="type">Int</span> = next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> generator = <span class="keyword">new</span> <span class="type">Generator</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">val</span> v1 = generator &gt;&gt; </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="前缀运算符"><a href="#前缀运算符" class="headerlink" title="前缀运算符"></a>前缀运算符</h3><p>和中缀运算符，后缀运算不同的是，Scala 只预留了四个前缀运算符 <code>!</code>，<code>+</code>, <code>-</code>, <code>~</code>。前缀运算符用于定义函数，参数列表只绑定一个操作数。用于前缀运算符的方法名称必须附带 <code>unary_</code> 前缀，它是一个无参数方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WarpedInt</span>(<span class="params">var v: <span class="type">Int</span></span>)</span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">unary_!</span> </span>: <span class="type">Int</span> = -v&#125;</span><br><span class="line"></span><br><span class="line">! <span class="keyword">new</span> <span class="type">WarpedInt</span>(<span class="number">20</span>)  <span class="comment">// return -20</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>使用前缀运算符的语句行必须要和其它语句行隔开，否则会被认为是跨行的中缀运算符运算而报错。如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WarpedInt</span>(<span class="params">var v: <span class="type">Int</span></span>)</span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">unary_!</span> </span>: <span class="type">Int</span> = -v&#125;</span><br><span class="line">! <span class="keyword">new</span> <span class="type">WarpedInt</span>(<span class="number">20</span>)  <span class="comment">// error: class WrapedInt(var v : Int)&#123;/**/&#125; ! new WarpedInt(20)</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>解决办法之一是上下两行间使用显式的 <code>;</code> 相隔。</p>
<h3 id="向右运算符"><a href="#向右运算符" class="headerlink" title="向右运算符"></a>向右运算符</h3><p>Scala 规定一切以 <code>:</code> 结尾的操作符是向右运算符，如 <code>::</code>，<code>/:</code>，<code>+:</code> 等，这都是在 Scala 不可变列表类型 <code>List[T]</code> 中实际定义的运算符。向右运算符是特殊的中缀运算符，方法的持有者位于操作符的右侧，而不是左侧。因此，<strong>这种运算符的计算次序是从右到左</strong>。</p>
<p>当向右运算符被作为普通方法调用时，运算顺序仍然是从左到右。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToLeft</span>(<span class="params">var seq : <span class="type">List</span>[<span class="type">Int</span>]</span>)</span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">&lt;-</span></span>:(i : <span class="type">Int</span>) : <span class="type">ToLeft</span> = <span class="keyword">new</span> <span class="type">ToLeft</span>(seq.appended(i))&#125;</span><br><span class="line"><span class="keyword">val</span> nil = <span class="keyword">new</span> <span class="type">ToLeft</span>(<span class="type">Nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sequenceList = (((nil.&lt;-:(<span class="number">1</span>)).&lt;-:(<span class="number">2</span>)).&lt;-:(<span class="number">3</span>)).&lt;-:(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> reversedList = <span class="number">1</span> &lt;-: <span class="number">2</span> &lt;-: <span class="number">3</span> &lt;-: <span class="number">4</span> &lt;-: nil</span><br><span class="line">println(reversedList.seq)  <span class="comment">// List(4,3,2,1)</span></span><br><span class="line">println(sequenceList.seq)  <span class="comment">// List(1,2,3,4)</span></span><br></pre></td></tr></table></figure>
<h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><blockquote>
<p>可以将 Scala 的分支结构看成是特殊的表达式，因为它们都具备返回值。</p>
</blockquote>
<h3 id="选择分支"><a href="#选择分支" class="headerlink" title="选择分支"></a>选择分支</h3><p>Scala 的选择分支具备返回值，因此它可以替代 Java 中的三目运算符 <code>? _ : _</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a : <span class="type">Int</span> = <span class="keyword">if</span> (<span class="type">Random</span>.nextInt() % <span class="number">2</span> == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>同样，每个语句块内最后一行表达式的计算结果会自动作为返回值。顺带一提，Scala 是崇尚简洁的语言：如果语句块只有单个的表达式或值，那么 <code>{}</code> 花括号就是多余的。</p>
<h4 id="switch分支的代替"><a href="#switch分支的代替" class="headerlink" title="switch分支的代替"></a>switch分支的代替</h4><p>Scala没有switch分支，取而代之的是模式匹配。比如</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; println(<span class="string">"result = 1"</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> =&gt; println(<span class="string">"result = 2"</span>)</span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println(<span class="string">"..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 <code>case</code> 声明了一个分支，分支之间不会穿透，<strong>程序会按顺序选择最先满足的分支并直接返回</strong>。注意，如果模式匹配没有成功执行任何一个分支，则会抛出 <code>MatchError</code> 异常。<code>case _ =&gt;</code> 相当于默认分支，它总是会满足匹配的条件。所以，这个分支应该被放到最后执行。</p>
<h4 id="for-表达式"><a href="#for-表达式" class="headerlink" title="for 表达式"></a>for 表达式</h4><p>在 Scala 中，for 表达式的实质是 <strong>函数式组合子的语法糖</strong>。这和其它语言中硬编码的 for 循环有本质的区别，语法风格也不同。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Scala 定长数组。</span></span><br><span class="line"><span class="keyword">val</span> arr: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span>(i &lt;- arr) println(i)</span><br></pre></td></tr></table></figure>
<p>上述代码的 for 表达式表示：将 <code>arr</code> 数组的每个元素依次赋值给 <code>i</code>，然后执行语句块 <code>println(i)</code>。</p>
<h5 id="1-to-与-until"><a href="#1-to-与-until" class="headerlink" title="1. to 与 until"></a>1. to 与 until</h5><p>Scala 不使用三段式控制 for 循环。如果要基于一个整数序列循环遍历，利用 <code>to</code> 可以直接创建一个闭区间 <code>[l,r]</code>，利用 <code>until</code> 可以直接创建一个左闭右开区间 <code>[l,r)</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span>) println(i)    <span class="comment">// 输出 1 到 10，等价于i=1; i&lt;=10; i++</span></span><br><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> until <span class="number">10</span>) println(i) <span class="comment">// 输出 1 到 9 ，等价于i=1; i&lt;10; 1++</span></span><br></pre></td></tr></table></figure>
<h5 id="2-根据数组下标迭代元素"><a href="#2-根据数组下标迭代元素" class="headerlink" title="2. 根据数组下标迭代元素"></a>2. 根据数组下标迭代元素</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arr.indices获取的是数组的下标，而非元素。</span></span><br><span class="line"><span class="keyword">for</span>(index &lt;- arr.indices) println(<span class="string">s"第<span class="subst">$&#123;index&#125;</span>个位置：<span class="subst">$&#123;arr(index)&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>
<p><code>indices</code> 方法在底层是 <code>0 until length</code> 的包装，其中 <code>length</code> 是数组的长度。</p>
<h5 id="3-循环守卫"><a href="#3-循环守卫" class="headerlink" title="3.循环守卫"></a>3.循环守卫</h5><p>Scala 在 for 表达式内使用 <code>if</code> 声明的循环守卫实现 continue 效果，循环守卫可以有多个。只有所有循环守卫的判断结果均为 <code>true</code>，才执行内部的语句块。比如，输出 10 以内的偶数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出0-10以内的偶数。</span></span><br><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">10</span> <span class="keyword">if</span> i % <span class="number">2</span> ==<span class="number">0</span>) println(i)</span><br></pre></td></tr></table></figure>
<h5 id="4-跨步迭代"><a href="#4-跨步迭代" class="headerlink" title="4.跨步迭代"></a>4.跨步迭代</h5><p>使用 <code>Range</code> 可以构造出一个 <code>[start,end)</code> 左闭右开区间 ，步长为 <code>step</code> 的序列。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Range</span>(start:<span class="type">Int</span>,end:<span class="type">Int</span>,step:<span class="type">Int</span>)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>比如，尝试生成 1 到 11 范围内的奇数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,3,5,7,9，但不包含11。</span></span><br><span class="line"><span class="keyword">for</span>(i &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>)) println(i)</span><br></pre></td></tr></table></figure>
<h5 id="5-嵌套组合for表达式"><a href="#5-嵌套组合for表达式" class="headerlink" title="5.嵌套组合for表达式"></a>5.嵌套组合for表达式</h5><p>我们偶尔会使用到嵌套的 for 循环来解决问题，以 Java 语言实现的冒泡排序为例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; arr.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] =arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr)&#123; System.out.println(i); &#125;</span><br></pre></td></tr></table></figure>
<p>下面是在 Scala 中的简化写法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- arr.indices; j &lt;- <span class="number">0</span> until arr.length - i <span class="number">-1</span> <span class="keyword">if</span> arr(j)&gt;arr(j+<span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">val</span> temp = arr(j)</span><br><span class="line">    arr(j) = arr(j+<span class="number">1</span>)</span><br><span class="line">    arr(j+<span class="number">1</span>) = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的代码还可以改写更易阅读的形式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    i &lt;- arr.indices </span><br><span class="line">    j &lt;- <span class="number">0</span> until arr.length - i <span class="number">-1</span> </span><br><span class="line">    <span class="keyword">if</span> arr(j)&gt;arr(j+<span class="number">1</span>)</span><br><span class="line">&#125;&#123;</span><br><span class="line">    <span class="keyword">val</span> temp = arr(j)</span><br><span class="line">    arr(j) = arr(j+<span class="number">1</span>)</span><br><span class="line">    arr(j+<span class="number">1</span>) = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-yieId"><a href="#6-yieId" class="headerlink" title="6.yieId"></a>6.yieId</h5><p>for表达式可以使用 <code>yield</code> 关键字收集每次循环的返回值并最终生成一个序列。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strings 是一个 immutable.IndexedSeq[Int] 类型。</span></span><br><span class="line"><span class="keyword">val</span> strings = <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>) <span class="keyword">yield</span> i.toString</span><br></pre></td></tr></table></figure>
<h4 id="while-do-while-不推荐"><a href="#while-do-while-不推荐" class="headerlink" title="while/do-while(不推荐)"></a>while/do-while(不推荐)</h4><p>这两类循环事实上很少使用。我们后期使用 Scala 解决问题的方式无非三种：</p>
<ol>
<li>各种 <code>flatMap</code>，<code>map</code>，<code>filter</code> 这样的组合子实现的数据流处理 ( 参考 Java 8 的流操作 )。</li>
<li>上述各种组合子的等效 for 表达式。</li>
<li>通过函数组合以及模式匹配实现的递归。</li>
</ol>
<p><code>while</code> / <code>do-while</code> 是一个充满了 <em>命令式编程</em> 风格的分支结构，这其实是和 Scala 推崇的 <em>声明式编程</em> 相悖的。另一方面，如果要使用 <code>while</code> / <code>do-while</code> 循环，那么就不可避免地需要通过监视外部变量来控制循环何时结束，这种做法被认为是破坏了代码的纯粹性。类似的案例是：如果在 Java 中尝试用 lambda 表达式内去更改 外部的值，程序也会拒绝编译。</p>
<p>总而言之，Scala 中使用 <code>while</code> / <code>do-while</code> 并不是一个明智的做法。比如说：<code>while</code> 循环内的 break 功能是通过抛出异常的方式完成的。这引入了大量不必要又难以记忆的代码块。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.control.<span class="type">Breaks</span>._</span><br><span class="line"><span class="comment">// 中断的 while 需要放到 breakable 内执行。</span></span><br><span class="line"><span class="comment">// ()=&gt;&#123;&#125; 可以类比 Java 的 Runnable。</span></span><br><span class="line">breakable(() =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) <span class="keyword">break</span>()</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="异常分支"><a href="#异常分支" class="headerlink" title="异常分支"></a>异常分支</h3><p><code>Java</code> 异常有两种，分别是 <em>受检异常</em> <code>Checked Exception</code> 和 <em>非受检异常</em> <code>Unchecked Exception</code></p>
<p>非受检异常指随着程序运行可能发生，又无法进行预料的错误，具体指 <code>java.lang.RuntimeException</code> 和 <code>java.lang.Error</code> 这两大类。非受检异常不强制要求捕获，也不强制要求使用 <code>throws</code> 声明向上抛出。</p>
<p><code>java.lang.RuntimeException</code> 指代由于逻辑问题引发的用户程序错误，如引用空指针的成员内容 <code>NullPointerException</code>，访问数组越界下标的内容 <code>ArrayIndexOutOfBoundsException</code> 这类异常一般是可恢复的，不至于让程序陷入 <em>宕机</em></p>
<p><code>java.lang.Error</code> 要比 <code>java.lang.RuntimeException</code> 严重，它意味着程序发生了不可恢复的致命错误：比如栈帧溢出，内存溢出等错误。</p>
<p>受检异常，一般用于受外部因素影响而存在失败风险的操作，比如加载外部类，读取外部文件等。Java 强制要求捕获这类异常并及时处理，否则就必须要在方法签名中通过 <code>throws</code> 关键字表示向上抛出。</p>
<p>Scala 沿用了 Java <code>try-catch</code> 的异常捕获体系，下面是一个简单的示例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> a: <span class="type">Int</span> = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">  println(a)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> ex: <span class="type">ArithmeticException</span> =&gt; ex.printStackTrace()</span><br><span class="line">  <span class="keyword">case</span> ex: <span class="type">Exception</span> =&gt; ex.printStackTrace()</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  println(<span class="string">"释放资源"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>catch</code> 块内是对 <strong>异常类型的模式匹配</strong>，从习惯上，小范围的异常写在大范围异常的前面。</p>
<p><strong>Scala 中只有运行时异常</strong>。说的再通俗点，我们不会在函数签名中通过 <code>throws</code> 标注任何可能抛出的受检异常。在后期基于函数的纯代数设计中，我们会理解这种侵入性的更改函数签名做法对于函数模块化组合没有任何好处。见：<a href="https://juejin.cn/post/7068196620692619277" target="_blank" rel="noopener">Scala：函数式编程下的异常处理 - 掘金 (juejin.cn)</a></p>
<p>Scala 可以在 <code>def</code> 函数上面加上一个 <code>@throws</code>注解的方式来 <em>标记</em>  可能抛出的异常：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@throws</span>(classOf[<span class="type">NumberFormatException</span>])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maybeFailed</span></span>(stringInt:<span class="type">String</span>): <span class="type">Int</span>= stringInt.toInt</span><br></pre></td></tr></table></figure>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2022/12/08/受检异常与非受检异常的区别/" data-toggle="tooltip" data-placement="top" title="受检异常与非受检异常的区别">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2022/11/21/IDEA创建Scala的maven项目/" data-toggle="tooltip" data-placement="top" title="IDEA创建Scala的maven项目">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="http://huangxuan.me" target="_blank">huangxuan Blog</a></li>
                    
                        <li><a href="#" target="_blank">Foo</a></li>
                    
                </ul>
                
            </div>

        </div>
    </div>
</article>




<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "hexo-theme-radiation_xuan&#39;s blog";
    var disqus_identifier = "https://radiationxuan.github.io/2022/11/29/Scala-变量，数据类型，运算符，分支结构/";
    var disqus_url = "https://radiationxuan.github.io/2022/11/29/Scala-变量，数据类型，运算符，分支结构/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/radiationxuan">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Jiaxuan&#39;s Blog 2022 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://radiationxuan.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-49627206-1';
    var _gaDomain = 'huangxuan.me';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '4cc1f2d8f3067386cc5cdb626a202900';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="https://radiationxuan.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
